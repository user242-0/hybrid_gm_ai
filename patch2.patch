diff --git a/scripts/run_eval_suite.py b/scripts/run_eval_suite.py
index 2a93801180eaef5f301672dacd24a7795214a963..f9b8357d2f62c57bf1085afe638f210a485f25da 100644
--- a/scripts/run_eval_suite.py
+++ b/scripts/run_eval_suite.py
@@ -109,56 +109,56 @@ def run_case(path: Path, batch_dir: Path, cfg: dict) -> bool:
     # ケース毎のジョブディレクトリ
     job_dir = batch_dir / path.stem
     if job_dir.exists():
         shutil.rmtree(job_dir)
     job_dir.mkdir(parents=True, exist_ok=True)
 
     # simulation_utils の出力先を差し替え
     importlib.reload(sim)  # 念のため再読込
     sim.SCENE_JOB_DIR = job_dir  # ← ここが肝
 
     # state 構築
     actor, gs = build_state_from_ctx(ctx)
     gs["eval_id"] = path.stem  # emotion_eval に載るメタ（任意）:contentReference[oaicite:18]{index=18}
 
     # 実行
     cmd = " ".join([action] + list(map(str, args or [])))
     sim.execute_player_choice(actor, cmd, gs)  # Emotion→WhyNow→SG→Story まで連鎖 :contentReference[oaicite:19]{index=19}
 
     # 検証
     ok = validate_outputs(job_dir, cfg, expect)
     print(("✓" if ok else "✗"), path.name, "->", job_dir)
     return ok
 
 def main():
     ap = argparse.ArgumentParser()
-    ap.add_argument("--glob", default="data/eval_set/cases/p2_*.yml")
+    ap.add_argument("--glob", default="data/eval_set/cases/p[23]_*.yml")
     ap.add_argument("--out", default=None, help="batch dir (default auto)")
     args = ap.parse_args()
 
     cfg = get_cfg()  # emit_policy / thresholds / job_dir_pattern を参照 :contentReference[oaicite:20]{index=20}
 
     # ★ out の決定ロジックを置き換え
     if args.out:
-        # 例: "jobs/%Y%m%d_%H%M_p2_suite_rerun" → jobs/20251025_1523_p2_suite_rerun
+        # 例: "jobs/%Y%m%d_%H%M_p_suite_rerun" → jobs/20251025_1523_p_suite_rerun
         try:
             out_str = datetime.now().strftime(args.out)
         except Exception:
             out_str = args.out  # 念のためフォールバック
     else:
         ts = datetime.now().strftime("%Y%m%d_%H%M%S")
-        out_str = f"jobs/{ts}_p2_suite"
+        out_str = f"jobs/{ts}_p_suite"
 
     batch_dir = Path(out_str)
     batch_dir.mkdir(parents=True, exist_ok=True)
 
     paths = sorted(Path(".").glob(args.glob))
     if not paths:
         print("no cases"); return
 
     print(f"Running {len(paths)} cases -> {batch_dir}")
     results = [run_case(p, batch_dir, cfg) for p in paths]
     passed = sum(1 for r in results if r)
     print(f"{passed}/{len(results)} passed")
 
 if __name__ == "__main__":
     main()
